# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#     https://docs.fastlane.tools/plugins/available-plugins

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

# ç¦ç”¨ä½¿ç”¨ç»Ÿè®¡
opt_out_usage

default_platform(:ios)

platform :ios do
  # ç¯å¢ƒå˜é‡é…ç½®
  APP_ID = ENV["APP_ID"] || "com.bto.Light"
  APP_NAME = ENV["APP_NAME"] || "BTOLIGHT"
  SCHEME_NAME = ENV["SCHEME_NAME"] || "taroApp"
  VERSION_NUMBER = ENV["VERSION_NUMBER"] || "1.0.0"
  BUILD_NUMBER = ENV["BUILD_NUMBER"] || Time.now.strftime("%Y%m%d%H%M")
  TEAM_ID = ENV["TEAM_ID"]
  PROVISIONING_PROFILE_SPECIFIER = ENV["PROVISIONING_PROFILE_SPECIFIER"]
  CODE_SIGN_IDENTITY = ENV["CODE_SIGN_IDENTITY"] || "Apple Distribution"
  
  # App Store Connect API é…ç½®
  API_KEY_ID = ENV["APP_STORE_CONNECT_API_KEY_ID"]
  ISSUER_ID = ENV["APP_STORE_CONNECT_ISSUER_ID"]
  
  before_all do
    # åœ¨ CI ç¯å¢ƒä¸­è·³è¿‡ Git æ£€æŸ¥
    unless ENV["SKIP_GIT_CHECK"] == "true" || ENV["CI"]
      ensure_git_status_clean
    end
    
    # è®¾ç½® App Store Connect API Key
    setup_app_store_connect_api_key if API_KEY_ID && ISSUER_ID
    
    # æ˜¾ç¤ºæ„å»ºä¿¡æ¯
    UI.header "ğŸš€ å¼€å§‹æ„å»º iOS åº”ç”¨"
    UI.message "ğŸ“± åº”ç”¨åç§°: #{APP_NAME}"
    UI.message "ğŸ†” Bundle ID: #{APP_ID}"
    UI.message "ğŸ·ï¸ ç‰ˆæœ¬å·: #{VERSION_NUMBER}"
    UI.message "ğŸ”¢ æ„å»ºå·: #{BUILD_NUMBER}"
    UI.message "ğŸ‘¥ å›¢é˜Ÿ ID: #{TEAM_ID}"
  end

  desc "ğŸ§ª è¿è¡Œæµ‹è¯•"
  lane :test do
    run_tests(
      scheme: SCHEME_NAME,
      device: "iPhone 15",
      clean: true,
      code_coverage: true,
      skip_build: false,
      result_bundle: true,
      output_directory: "./test_output"
    )
  end

  desc "ğŸš€ æ„å»ºå¹¶å‘å¸ƒåˆ° App Store"
  lane :release do
    # æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯
    update_app_version
    
    # æ„å»ºåº”ç”¨
    build_app_store_version
    
    # ä¸Šä¼ åˆ° App Store Connect
    upload_to_app_store_connect
    
    # å‘é€é€šçŸ¥
    notify_success("âœ… #{APP_NAME} å·²æˆåŠŸå‘å¸ƒåˆ° App Store Connect")
  end

  desc "ğŸ§ª æ„å»ºå¹¶ä¸Šä¼  TestFlight ç‰ˆæœ¬"
  lane :beta do
    # æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯
    update_app_version
    
    # æ„å»º TestFlight ç‰ˆæœ¬
    build_testflight_version
    
    # ä¸Šä¼ åˆ° TestFlight
    upload_testflight_build
    
    # å‘é€é€šçŸ¥
    notify_success("âœ… #{APP_NAME} æµ‹è¯•ç‰ˆæœ¬å·²ä¸Šä¼ åˆ° TestFlight")
  end

  desc "ğŸ—ï¸ ä»…æ„å»ºåº”ç”¨"
  lane :build_only do
    update_app_version
    build_app_store_version
    notify_success("âœ… #{APP_NAME} æ„å»ºå®Œæˆ")
  end

  desc "ğŸ“‹ æ›´æ–°åº”ç”¨ç‰ˆæœ¬ä¿¡æ¯"
  private_lane :update_app_version do
    UI.header "ğŸ“‹ æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯"
    
    # æ›´æ–°ç‰ˆæœ¬å·
    increment_version_number(
      version_number: VERSION_NUMBER,
      xcodeproj: "#{SCHEME_NAME}.xcodeproj"
    )
    
    # æ›´æ–°æ„å»ºå·
    increment_build_number(
      build_number: BUILD_NUMBER,
      xcodeproj: "#{SCHEME_NAME}.xcodeproj"
    )
    
    UI.success "ç‰ˆæœ¬å·å·²æ›´æ–°ä¸º: #{VERSION_NUMBER}"
    UI.success "æ„å»ºå·å·²æ›´æ–°ä¸º: #{BUILD_NUMBER}"
  end

  desc "ğŸ—ï¸ æ„å»º App Store ç‰ˆæœ¬"
  private_lane :build_app_store_version do
    UI.header "ğŸ—ï¸ æ„å»º App Store ç‰ˆæœ¬"
    
    # æ¸…ç†æ„å»ºç¼“å­˜
    cleanup_build_files
    
    # æ„å»ºåº”ç”¨
    build_app(
      scheme: SCHEME_NAME,
      configuration: "Release",
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          APP_ID => PROVISIONING_PROFILE_SPECIFIER
        },
        signingStyle: "manual",
        teamID: TEAM_ID,
        compileBitcode: false,
        uploadBitcode: false,
        uploadSymbols: true,
        manageAppVersionAndBuildNumber: false,
        destination: "export"
      },
      output_directory: "./build",
      output_name: "#{APP_NAME}_#{VERSION_NUMBER}_#{BUILD_NUMBER}_AppStore.ipa",
      clean: true,
      include_symbols: true,
      include_bitcode: false,
      silent: false,
      suppress_xcode_output: false
    )
    
    UI.success "App Store ç‰ˆæœ¬æ„å»ºå®Œæˆ: #{lane_context[SharedValues::IPA_OUTPUT_PATH]}"
  end

  desc "ğŸ§ª æ„å»º TestFlight ç‰ˆæœ¬"
  private_lane :build_testflight_version do
    UI.header "ğŸ§ª æ„å»º TestFlight ç‰ˆæœ¬"
    
    # æ¸…ç†æ„å»ºç¼“å­˜
    cleanup_build_files
    
    # ç¦ç”¨ Hermesï¼ˆå¦‚æœç¯å¢ƒå˜é‡è®¾ç½®ï¼‰
    # disable_hermes_if_needed
    
    # ç¡®ä¿æœ‰æ­£ç¡®çš„ç­¾åé…ç½®
    update_code_signing_settings(
      use_automatic_signing: false,
      team_id: TEAM_ID,
      code_sign_identity: CODE_SIGN_IDENTITY,
      profile_name: PROVISIONING_PROFILE_SPECIFIER,
      path: "taroApp.xcodeproj"
    )
    
    # æ„å»ºåº”ç”¨
    build_app(
      scheme: SCHEME_NAME,
      configuration: "Release",
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          APP_ID => PROVISIONING_PROFILE_SPECIFIER
        },
        signingStyle: "manual",
        teamID: TEAM_ID,
        compileBitcode: false,
        uploadBitcode: false,
        uploadSymbols: true,
        manageAppVersionAndBuildNumber: false
      },
      output_directory: "./build",
      output_name: "#{APP_NAME}_#{VERSION_NUMBER}_#{BUILD_NUMBER}_TestFlight.ipa",
      clean: true,
      include_symbols: true,
      include_bitcode: false
    )
    
    UI.success "TestFlight ç‰ˆæœ¬æ„å»ºå®Œæˆ: #{lane_context[SharedValues::IPA_OUTPUT_PATH]}"
  end

  desc "ğŸ“¤ ä¸Šä¼ åˆ° App Store Connect"
  private_lane :upload_to_app_store_connect do
    UI.header "ğŸ“¤ ä¸Šä¼ åˆ° App Store Connect"
    
    begin
      upload_to_app_store(
        ipa: lane_context[SharedValues::IPA_OUTPUT_PATH],
        skip_screenshots: true,
        skip_metadata: true,
        skip_app_version_update: true,
        force: true,
        precheck_include_in_app_purchases: false,
        submit_for_review: false,
        automatic_release: false,
        platform: "ios",
        verify_only: false
      )
      
      UI.success "åº”ç”¨å·²æˆåŠŸä¸Šä¼ åˆ° App Store Connect"
    rescue => exception
      UI.error "ä¸Šä¼ åˆ° App Store Connect å¤±è´¥: #{exception.message}"
      notify_failure("âŒ #{APP_NAME} ä¸Šä¼ åˆ° App Store Connect å¤±è´¥: #{exception.message}")
      raise exception
    end
  end

  desc "ğŸ“¤ ä¸Šä¼ åˆ° TestFlight"
  private_lane :upload_testflight_build do
    UI.header "ğŸ“¤ ä¸Šä¼ åˆ° TestFlight"
    
    upload_to_testflight(
      ipa: lane_context[SharedValues::IPA_OUTPUT_PATH],
      skip_waiting_for_build_processing: true,
      skip_submission: true,
      distribute_external: false,
      notify_external_testers: false,
      changelog: "é€šè¿‡ Fastlane è‡ªåŠ¨æ„å»ºå’Œä¸Šä¼ "
    )
    
    UI.success "ğŸ‰ åº”ç”¨å·²æˆåŠŸä¸Šä¼ åˆ° TestFlight!"
    notify_success("ğŸ‰ TestFlight ä¸Šä¼ æˆåŠŸ: åº”ç”¨ #{APP_NAME} v#{VERSION_NUMBER}(#{BUILD_NUMBER}) å·²æˆåŠŸä¸Šä¼ åˆ° TestFlight")
  end

  desc "ğŸ”‘ è®¾ç½® App Store Connect API Key"
  private_lane :setup_app_store_connect_api_key do
    app_store_connect_api_key(
      key_id: API_KEY_ID,
      issuer_id: ISSUER_ID,
      key_filepath: "~/.appstoreconnect/private_keys/AuthKey_#{API_KEY_ID}.p8",
      duration: 1200,
      in_house: false
    )
    UI.success "App Store Connect API Key é…ç½®å®Œæˆ"
  end

  desc "ğŸ§¹ æ¸…ç†æ„å»ºæ–‡ä»¶"
  private_lane :cleanup_build_files do
    UI.header "ğŸ§¹ æ¸…ç†æ„å»ºæ–‡ä»¶"
    
    # æ¸…ç† Xcode æ„å»ºç¼“å­˜
    clear_derived_data
    
    # æ¸…ç†ä¹‹å‰çš„æ„å»ºæ–‡ä»¶
    sh("rm -rf ../build") if File.exist?("../build")
    
    # æ¸…ç† gym è¾“å‡º
    sh("rm -rf ./gym") if File.exist?("./gym")
    
    UI.success "æ„å»ºæ–‡ä»¶æ¸…ç†å®Œæˆ"
  end

  desc "ğŸ“¢ å‘é€æˆåŠŸé€šçŸ¥"
  private_lane :notify_success do |message|
    UI.success message
    
    # Slack é€šçŸ¥
    if ENV["SLACK_WEBHOOK_URL"]
      slack(
        message: message,
        webhook_url: ENV["SLACK_WEBHOOK_URL"],
        channel: ENV["SLACK_CHANNEL"] || "#ios-builds",
        username: "iOS Build Bot",
        icon_emoji: ":rocket:",
        success: true,
        payload: {
          "Build Number" => BUILD_NUMBER,
          "Version" => VERSION_NUMBER,
          "App Name" => APP_NAME
        }
      )
    end
    
    # ä¼ä¸šå¾®ä¿¡é€šçŸ¥
    if ENV["WECHAT_WEBHOOK_URL"]
      wechat_work(
        webhook_url: ENV["WECHAT_WEBHOOK_URL"],
        message: message
      )
    end
  end

  desc "ğŸ“¢ å‘é€å¤±è´¥é€šçŸ¥"
  private_lane :notify_failure do |message|
    UI.error message
    
    # Slack é€šçŸ¥
    if ENV["SLACK_WEBHOOK_URL"]
      slack(
        message: message,
        webhook_url: ENV["SLACK_WEBHOOK_URL"],
        channel: ENV["SLACK_CHANNEL"] || "#ios-builds",
        username: "iOS Build Bot",
        icon_emoji: ":x:",
        success: false,
        payload: {
          "Build Number" => BUILD_NUMBER,
          "Version" => VERSION_NUMBER,
          "App Name" => APP_NAME
        }
      )
    end
  end

  # ä¿®å¤é”™è¯¯å¤„ç†
  error do |lane, exception, options|
    UI.error "Lane #{lane} æ‰§è¡Œå¤±è´¥"
    UI.error "é”™è¯¯ä¿¡æ¯: #{exception.message}"
    
    # æ¸…ç†æ„å»ºæ–‡ä»¶
    cleanup_build_files
    
    # å‘é€é”™è¯¯é€šçŸ¥
    notify_failure("âŒ æ„å»ºå¤±è´¥: Lane #{lane} æ‰§è¡Œå¤±è´¥: #{exception.message}")
  end

  after_all do |lane, options|
    UI.success "ğŸ‰ Lane #{lane} æ‰§è¡Œå®Œæˆ"
    cleanup_build_files
  end
end